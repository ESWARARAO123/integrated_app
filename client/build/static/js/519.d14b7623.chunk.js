"use strict";(self.webpackChunkclient=self.webpackChunkclient||[]).push([[519],{2519:(t,e,o)=>{o.r(e),o.d(e,{default:()=>a});var n=o(2932);const a={sendChatCompletion:async t=>(await n.F.post("/mcp/chat",t)).data,streamChatCompletion:async(t,e,o,n)=>{let a="";const s=new AbortController,i=s.signal;let r=!1;try{var c;t.options&&t.options.stream||(t.options={...t.options,stream:!0});const n=await fetch("/api/mcp/chat",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t),signal:i});if(!n.ok){const t=await n.json();throw new Error(t.error||"Failed to stream chat completion")}const s=null===(c=n.body)||void 0===c?void 0:c.getReader();if(!s)throw new Error("ReadableStream not supported");const w=new TextDecoder;let v=!1;for(;!v&&!r;){const{value:o,done:n}=await s.read();if(v=n,v)break;const i=w.decode(o).trim().split("\n\n");for(const s of i)if(s.startsWith("data: "))try{var l,d,h,p,u,m;const o=s.slice(6);if(""===o||"[DONE]"===o)continue;const n=JSON.parse(o);let i;i=n.choices?n:n.content?{id:`chunk-${Date.now()}`,created:Date.now(),model:t.modelId||"",choices:[{index:0,delta:{content:n.content},message:{role:"assistant",content:n.content},finish_reason:null}]}:{id:`chunk-${Date.now()}`,created:Date.now(),model:t.modelId||"",choices:[{index:0,delta:{content:JSON.stringify(n)},message:{role:"assistant",content:JSON.stringify(n)},finish_reason:null}]},e(i);if(a+=(null===(l=i.choices)||void 0===l||null===(d=l[0])||void 0===d||null===(h=d.delta)||void 0===h?void 0:h.content)||(null===(p=i.choices)||void 0===p||null===(u=p[0])||void 0===u||null===(m=u.message)||void 0===m?void 0:m.content)||"",n.done){v=!0;break}}catch(f){console.error("Error parsing chunk:",f,s)}}r||o()}catch(w){r||"AbortError"===w.name||n(w)}return()=>{r=!0,s.abort(),o()}}}}}]);